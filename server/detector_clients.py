import os
import random
import json
import re
import httpx
import logging
from dotenv import load_dotenv

# Load environment variables from a .env file if present so
# OPENAI_API_KEY and other development settings are available.
load_dotenv()

PROVIDER = os.getenv('DETECTOR_PROVIDER')

# module logger
logger = logging.getLogger(__name__)


async def ai_score(text: str) -> float:
	"""Dispatch to chosen detector provider.

	Supported providers: openai, mock
	"""
	if PROVIDER == 'openai':
		logger.debug('entry: openai')
		return await _openai_score(text)
	logger.debug('entry: mock')
	return _mock_score(text)

def _mock_score(text: str) -> float:
	print('mock score')
	# naive heuristic fallback for local dev
	# more punctuation variety -> more human-ish (toy example!)
	punct_chars = set([',', '.', ';', ':', '!', '?', '(', ')', '"', "'", '-', '–', '—'])
	unique_punct = len({c for c in text if c in punct_chars})
	score = 0.7 - min(unique_punct / 80.0, 0.5)
	# jitter a bit so UI looks alive
	return max(0.0, min(1.0, score + random.uniform(-0.05, 0.05)))


def _truncate_text_for_model(text: str, max_chars: int = 12000) -> str:
	"""Naive truncation that keeps the start and end of a long text to preserve signals."""
	if len(text) <= max_chars:
		return text
	head = text[: int(max_chars * 0.6)]
	tail = text[-int(max_chars * 0.4) :]
	return head + "\n\n...[TRUNCATED]...\n\n" + tail


async def _openai_score(text: str) -> float:
    logger = logging.getLogger(__name__)
    print('openai_score')

    api_key = os.getenv('OPENAI_API_KEY')
    if not api_key:
        logger.warning('OPENAI_API_KEY not set; returning neutral score')
        return 0.5

    model = os.getenv('OPENAI_MODEL', 'gpt-5-nano')
    truncated = _truncate_text_for_model(text)

    system = (
        "You are an assistant that estimates the likelihood that a given text was generated by an AI. "
        "Respond with a single JSON object only, containing a numeric field 'ai_score' with a value between 0.0 and 1.0."
    )
    user = f"Analyze the following text and return JSON only:\n\n{truncated}"

    payload = {
        "model": model,
        "messages": [
            {"role": "system", "content": system},
            {"role": "user", "content": user},
        ],
        # JSON 전용 출력 유도 (모델에 따라 무시될 수 있음)
        "response_format": {"type": "json_object"},
    }

    # 일부 모델은 temperature=0.0을 거부할 수 있어 생략
    # payload["temperature"] = 0.0

    async with httpx.AsyncClient(timeout=60) as client:
        resp = await client.post(
            "https://api.openai.com/v1/chat/completions",
            headers={
                "Authorization": f"Bearer {api_key}",
                "Content-Type": "application/json",
            },
            json=payload,
        )

    body_text = resp.text
    logger.debug("OpenAI status=%s", resp.status_code)
    if resp.status_code >= 400:
        logger.warning("OpenAI error body preview: %s", body_text[:1000])
        try:
            resp.raise_for_status()
        except Exception:
            return 0.5

    data = {}
    try:
        data = resp.json()
    except Exception:
        logger.exception("Failed to parse JSON from OpenAI")
        return 0.5

    content = ""

    # ------- 1) chat/completions 기본 경로 -------
    try:
        choices = data.get("choices") or []
        if choices:
            ch0 = choices[0]
            msg = ch0.get("message") or {}
            # (a) message.content (str or list)
            mc = msg.get("content")
            if isinstance(mc, str) and mc.strip():
                content = mc
                logger.debug("content from message.content (str)")
            elif isinstance(mc, list) and mc:
                # list 파츠 합치기
                parts = []
                for it in mc:
                    if isinstance(it, str):
                        parts.append(it)
                    elif isinstance(it, dict):
                        # type/text 형태
                        if "text" in it and isinstance(it["text"], str):
                            parts.append(it["text"])
                if parts:
                    content = "".join(parts)
                    logger.debug("content from message.content (list parts)")
            # (b) tool_calls → function.arguments
            if not content and isinstance(msg.get("tool_calls"), list) and msg["tool_calls"]:
                tc0 = msg["tool_calls"][0]
                fn = tc0.get("function") or {}
                args = fn.get("arguments")
                if isinstance(args, str) and args.strip():
                    # JSON일 가능성 높음
                    try:
                        parsed = json.loads(args)
                        val = parsed.get("ai_score")
                        if isinstance(val, (int, float)):
                            logger.info("ai_score from tool_calls.function.arguments")
                            return float(max(0.0, min(1.0, float(val))))
                    except Exception:
                        # 문자열로 들어왔으면 content로 재활용
                        content = args
                        logger.debug("content from tool_calls.function.arguments (string)")
    except Exception:
        logger.exception("While extracting from chat/completions 'choices'")

    # ------- 2) 기타 응답 포맷(output/outputs/results/response) -------
    if not content and isinstance(data, dict):
        for out_key in ("output", "outputs", "results", "response"):
            out = data.get(out_key)
            if isinstance(out, list) and out:
                first = out[0]
                if isinstance(first, dict):
                    c = first.get("content") or first.get("text") or first.get("message")
                    if isinstance(c, str) and c.strip():
                        content = c
                        logger.debug("content from outputs-like[str]")
                        break
                    if isinstance(c, list):
                        parts = []
                        for it in c:
                            if isinstance(it, dict):
                                if "text" in it and isinstance(it["text"], str):
                                    parts.append(it["text"])
                                elif it.get("type") == "output_text" and "text" in it:
                                    parts.append(it["text"])
                            elif isinstance(it, str):
                                parts.append(it)
                        if parts:
                            content = "".join(parts)
                            logger.debug("content from outputs-like[list parts]")
                            break
                    if isinstance(c, dict) and "text" in c and isinstance(c["text"], str):
                        content = c["text"]
                        logger.debug("content from outputs-like[dict text]")
                        break

    # ------- 3) 최후의 보루: 상위 필드들 -------
    if not content and isinstance(data, dict):
        for k in ("message", "text", "result", "output_text", "generated_text"):
            v = data.get(k)
            if isinstance(v, str) and v.strip():
                content = v
                logger.debug("content from top-level field: %s", k)
                break

    # ------- 파싱: JSON 우선, 그 다음 숫자/퍼센트 -------
    if content:
        logger.info("OpenAI content preview: %s", content[:200].replace("\n", " "))
        # JSON 객체 추출
        m = re.search(r"\{[\s\S]*\}", content)
        if m:
            try:
                parsed = json.loads(m.group(0))
                val = parsed.get("ai_score")
                if isinstance(val, (int, float)):
                    return float(max(0.0, min(1.0, float(val))))
            except Exception:
                pass
        # 0~1 소수
        num_m = re.search(r"\b(0(?:\.\d+)?|1(?:\.0+)?)\b", content)
        if num_m:
            try:
                return float(num_m.group(1))
            except Exception:
                pass
        # % 표시
        pct_m = re.search(r"\b(\d{1,3})\s*%\b", content)
        if pct_m:
            try:
                pct = float(pct_m.group(1)) / 100.0
                return max(0.0, min(1.0, pct))
            except Exception:
                pass
    else:
        logger.warning("OpenAI response had no extractable content. data keys=%s", list(data.keys()))

    logger.debug("returning neutral score after parse failure")
    return 0.5
